#include "GAgentManager.h"
#include "GAgent.h"
// #include "GAgentPlugin.h"
// #include "GAgentShelf.h"
#include <QMimeData>
#include <QSettings>
#include <QtGui>

GAgentManager::GAgentManager()
 	: m_pHardAgentShelf(0)
{

}

GAgentManager::~GAgentManager()
{

}

// void GAgentManager::AddAgentToShelf( GAgent* pAgent )
// {
// 	if(!pAgent)
// 		return;
// 	// if the shelf doesn't exist, let's create it. Cannot be done in the constructor because it is being called before the app actually starts.
// 	HardwareAgentShelf()->AddAgent(pAgent);
// 	m_CleanUpAgents.add(pAgent);
// }
// 
// void GAgentManager::MakeTheAgentShelf() const
// {
// 	if(!m_pHardAgentShelf) {
// 		m_pHardAgentShelf = new GAgentShelf(0);
// 		m_CleanUpAgents.add(m_pHardAgentShelf);
// 	}
// }

QList<QString> GAgentManager::RegisteredAgentTypes() const
{
	std::vector<QString> ids = AgentManagerInstance()->RegisteredIds();
	QList<QString> typlist;
	for(int i = 0; i < (int)ids.size(); i++) {
		typlist.append(ids[i]);
	}
	return typlist;

}

GAgent* GAgentManager::CreateNewAgent( QString className, QString uniqueIdentifierName, QObject *parent ) const
{
	return AgentManagerInstance()->CreateObject( className, uniqueIdentifierName, parent);
}

GAgent* GAgentManager::CreateNewProgAgent( QString className, QObject *parent ) const
{
	// warn if not in RegisteredProgAgents() to prevent using this function on an hardware Agent.
	// actually it warns only if the className is a hardware Agent class name to. (so that it doesn't warn for nothing)
	if(RegisteredProgAgents().contains(className))
		return AgentManagerInstance()->CreateObject( className, "" /*has to be "" so that the ID is generated by the Agent*/, parent);
	else if(RegisteredAgentTypes().contains(className))
		qWarning("The Agent specified seems to be a hardware Agent, NOT a GProgAgent. 4911647");
	return 0;
}

/////////////////////////////////////////////////////////////////////
/*!
Note that this overload will actually try to CreateNewProgAgent() if theMimeData contains the name of such a class.
Note also that in such a case, the created object has a parent set to 0.
\return: GAgent* : pointer to the GAgent or created GProgAgent object. 0 if no match.
\param:  const QMimeData * theMimeData : from e.g. a DropEvent. It must hasFormat("LabExe/agent.single");
*////////////////////////////////////////////////////////////////////
GAgent* GAgentManager::GetAgent( const QMimeData* theMimeData ) const
{
	// extrapolation from qt help: "Using Drag and Drop with Item Views"
	if(!theMimeData)
		return 0;
	if(!theMimeData->hasFormat("LabExe/agent.single")) 
		return 0;
	QByteArray encodedData = theMimeData->data("LabExe/agent.single");
	QDataStream devStream(&encodedData, QIODevice::ReadOnly);
	if(devStream.atEnd()) 
		return 0;	
	QString devStrIDorClass;
	devStream >> devStrIDorClass;

	GAgent* pTheAgent = AgentManagerInstance()->GetAgent(devStrIDorClass);
	// if there is no return, maybe we can try the CreateNewProgAgent(), just in case the data were from a drop of a GProgAgent.
	if(!pTheAgent)
		pTheAgent = CreateNewProgAgent(devStrIDorClass, 0);
	// we return the result, which is 0 if nothing worked.
	return pTheAgent;
}

void GAgentManager::LoadAgentPlugins()
{
	QStringList pluginFileNames;
	// code taken from the plug and paint Qt example !
	QDir pluginsDir = QDir(qApp->applicationDirPath());

#if defined(Q_OS_WIN)
// 	if (pluginsDir.dirName().toLower() == "debug" || pluginsDir.dirName().toLower() == "release")
 		pluginsDir.cdUp();
#elif defined(Q_OS_MAC)
    if (pluginsDir.dirName() == "MacOS") {
// 		pluginsDir.cdUp();
    pluginsDir.cdUp();
    pluginsDir.cdUp();
    }
#endif
    qDebug()<<pluginsDir;

	pluginsDir.cd("plugins");
	qDebug() << "Loading plugins from: " << pluginsDir.path();

	// for the folder and each sub-folders in the plugin directory
	foreach(QString dirName, pluginsDir.entryList(QDir::AllDirs | QDir::NoDotDot)) {
		QDir agentDir(pluginsDir);
		agentDir.cd(dirName);
// 		qDebug() << agentDir.absolutePath();
		// for each file in the folder
		foreach(QString fileName, agentDir.entryList(QDir::Files)) {
			QPluginLoader loader(agentDir.absoluteFilePath(fileName), this);
			bool didLoad = loader.isLoaded();
			if(!didLoad) {

			}
			QObject *plugin = loader.instance();
			if(plugin)
				m_CleanUpAgents.add(plugin);
// 			GAgentPlugin* pAgentPlugin = qobject_cast<GAgentPlugin*>(plugin);
// 			// if there is a pAgentPlugin, we register it with the agent manager.
// 			if(pAgentPlugin) {
// 				pluginFileNames += fileName;
// 				pAgentPlugin->RegisterAgentClassInAgentManager();
// 			}
		}
	}
}

void GAgentManager::Add( GAgent* pAgent )
{
	if(!pAgent)
		return;
	insert(pAgent->UniqueSystemID(), pAgent);
//	m_CleanUpAgents.add(pAgent);
}
