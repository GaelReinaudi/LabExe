#include "GDeviceManager.h"
#include "GDevice.h"
#include "GDevicePlugin.h"
#include "GDeviceShelf.h"
#include <QMimeData>
#include <QSettings>
#include <QtWidgets>

GDeviceManager::GDeviceManager()
 	: m_pHardDeviceShelf(0)
{

}

GDeviceManager::~GDeviceManager()
{

}

void GDeviceManager::AddDeviceToShelf( GDevice* pDevice )
{
	if(!pDevice)
		return;
	// if the shelf doesn't exist, let's create it. Cannot be done in the constructor because it is being called before the app actually starts.
	HardwareDeviceShelf()->AddDevice(pDevice);
	m_CleanUpDevices.add(pDevice);
}

void GDeviceManager::MakeTheDeviceShelf() const
{
	if(!m_pHardDeviceShelf) {
		m_pHardDeviceShelf = new GDeviceShelf(0);
		m_CleanUpDevices.add(m_pHardDeviceShelf);
	}
}

QList<QString> GDeviceManager::RegisteredDeviceTypes() const
{
	std::vector<QString> ids = DeviceManagerInstance()->RegisteredIds();
	QList<QString> typlist;
	for(int i = 0; i < (int)ids.size(); i++) {
		typlist.append(ids[i]);
	}
	return typlist;

}

GDevice* GDeviceManager::CreateNewDevice( QString className, QString uniqueIdentifierName, QObject *parent ) const
{
	return DeviceManagerInstance()->CreateObject( className, uniqueIdentifierName, parent);
}

GDevice* GDeviceManager::CreateNewProgDevice( QString className, QObject *parent ) const
{
	// warn if not in RegisteredProgDevices() to prevent using this function on an hardware device.
	// actually it warns only if the className is a hardware device class name to. (so that it doesn't warn for nothing)
	if(RegisteredProgDevices().contains(className))
		return DeviceManagerInstance()->CreateObject( className, "" /*has to be "" so that the ID is generated by the device*/, parent);
	else if(RegisteredDeviceTypes().contains(className))
		qWarning("The device specified seems to be a hardware device, NOT a GProgDevice. 4911647");
	return 0;
}

/////////////////////////////////////////////////////////////////////
/*!
Note that this overload will actually try to CreateNewProgDevice() if theMimeData contains the name of such a class.
Note also that in such a case, the created object has a parent set to 0.
\return: GDevice* : pointer to the GDevice or created GProgDevice object. 0 if no match.
\param:  const QMimeData * theMimeData : from e.g. a DropEvent. It must hasFormat("LabExe/device.single");
*////////////////////////////////////////////////////////////////////
GDevice* GDeviceManager::GetDevice( const QMimeData* theMimeData ) const
{
	// extrapolation from qt help: "Using Drag and Drop with Item Views"
	if(!theMimeData)
		return 0;
	if(!theMimeData->hasFormat("LabExe/device.single")) 
		return 0;
	QByteArray encodedData = theMimeData->data("LabExe/device.single");
	QDataStream devStream(&encodedData, QIODevice::ReadOnly);
	if(devStream.atEnd()) 
		return 0;	
	QString devStrIDorClass;
	devStream >> devStrIDorClass;

	GDevice* pTheDevice = DeviceManagerInstance()->GetDevice(devStrIDorClass);
	// if there is no return, maybe we can try the CreateNewProgDevice(), just in case the data were from a drop of a GProgDevice.
	if(!pTheDevice)
		pTheDevice = CreateNewProgDevice(devStrIDorClass, 0);
	// we return the result, which is 0 if nothing worked.
	return pTheDevice;
}

void GDeviceManager::LoadDevicePlugins()
{
	QStringList pluginFileNames;
	// code taken from the plug and paint Qt example !
	QDir pluginsDir = QDir(qApp->applicationDirPath());
    qDebug() << pluginsDir;

#if defined(Q_OS_WIN)
// 	if (pluginsDir.dirName().toLower() == "debug" || pluginsDir.dirName().toLower() == "release")
 		pluginsDir.cdUp();
#elif defined(Q_OS_MAC)
    if (pluginsDir.dirName() == "MacOS") {
// 		pluginsDir.cdUp();
    pluginsDir.cdUp();
    //pluginsDir.cdUp();
    }
#endif
    qDebug()<<pluginsDir;

	pluginsDir.cd("plugins");
	qDebug() << "Loading plugins from: " << pluginsDir.path();

	// for the folder and each sub-folders in the plugin directory
	foreach(QString dirName, pluginsDir.entryList(QDir::AllDirs | QDir::NoDotDot)) {
		QDir deviceDir(pluginsDir);
		deviceDir.cd(dirName);
// 		qDebug() << deviceDir.absolutePath();
		// for each file in the folder
		foreach(QString fileName, deviceDir.entryList(QDir::Files)) {
			QFileInfo finfo(fileName);
			//if(finfo.suffix() == "dll")
			//	qDebug() << "trying to load " << fileName;
			QPluginLoader loader(deviceDir.absoluteFilePath(fileName), this);
			loader.load();
			bool didLoad = loader.isLoaded();
			if(didLoad)
				qDebug() << finfo.baseName();
			else {
				if(finfo.suffix() == "dll")
					qDebug() << "couldn't load " << fileName;
			}
			QObject *plugin = loader.instance();
			GDevicePlugin* pDevicePlugin = qobject_cast<GDevicePlugin*>(plugin);
			// if there is a pDevicePlugin, we register it with the device manager.
			if(pDevicePlugin) {
				m_CleanUpDevices.add(pDevicePlugin);
				pluginFileNames += fileName;
				pDevicePlugin->RegisterDeviceClassInDeviceManager();
			}
		}
	}
}

void GDeviceManager::Add( GDevice* pDevice )
{
	if(!pDevice)
		return;
	insert(pDevice->UniqueSystemID(), pDevice);
//	m_CleanUpDevices.add(pDevice);
}
