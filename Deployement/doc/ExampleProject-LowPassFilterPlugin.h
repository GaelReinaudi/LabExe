/*! \file ExampleProject-LowPassFilterPlugin.h
* \brief A tutorial about a plugin project that produces a low-pass filter device
*
*/
/*!

\page ExampleProject-LowPassFilterPlugin Example Project: Low-pass filter plugin

- \ref InstallProject
- \ref LowPassFilterBreakDown
	- \ref LowPassProjectStructure
	- \ref LowPassFiles
- \ref GLowPassFilterClass
	- \ref GLowPassFilterClass-Inheritance
	- \ref GLowPassFilterClass-variables
	- \ref GLowPassFilterClass-GParamAdvantage
	- \ref GLowPassFilterClass-variablesInit
	- \ref GLowPassFilterClass-guiBetter





\section InstallProject Get started: Install the project and run the plugin

Be sure to have complied with the pre-requisite installation so that you can compile the source code. 
\see \ref PreRequisiteInstallation

This will install a visual studio project:
<em>[PROGRAM FILES]/LabExe/examples/LowPassFilterPlugin/LowPassFilterPlugin.vcproj</em>

Opening this project will start visual studio. 
Then:
- Press F7 to compile the project and copy the dll in the appropriate directory.
- Press F5 to start the LabExe program using this plugin in a debugging mode.

There you go, the Low-pass filter plugin should appear in the <em>e-Device shelf</em>






\section LowPassFilterBreakDown Code breakdown: what is going on in the Low-pass filter project



\subsection LowPassProjectStructure Project structure
The Visual Studio project is composed of a few parts
\image html LowPassFilter-ProjectTree.png
- <em>Generated Files</em>. Those are files generated by the Qt meta-object compiler and we don't have to deal with them.
- <em>Header Files</em> and <em>Source Files</em>. Those contain the actual code for the plugin.



\subsection LowPassFiles Files
- LowPassFilterPlugin_global.h is just a 4-line header file that Qt/C++ uses to organize the making of a dll
- \e LowPassFilterPlugin.h and \e LowPassFilterPlugin.cpp are two files, with only a few lines, that say 
<em>"This library is actually a plugin for a new device in LabExe and the device is defined by the class GLowPassFilter"</em>. 
You may notice that the library class, \e GLowPassFilterPlugin, inherit from GDevicePlugin.
- the files \e GLowPassFilter.h and \e GLowPassFilter.cpp declare and define the Soft-Device GLowPassFilter. 
This happens by having this class inherit GProgDevice. This is the class in which there is the code that 
defines the interface and behaviour of the low-pass filter device.






\section GLowPassFilterClass Breakdown of the GLowPassFilter class



\subsection GLowPassFilterClass-Inheritance Ineritance from GProgDevice

In order to be adequately represented in the labee program, the GLowPassFilter class has 
to inherit the GProgDevice class.

\snippet LowPassFilterPlugin/GLowPassFilter.h inheritance

Also, the constructor of the class has the same signature as  the GProgDevice::GProgDevice() constructor.

\snippet LowPassFilterPlugin/GLowPassFilter.h constructor



\subsection GLowPassFilterClass-variables Defining variables

The variables that are relevant to our Low-pass filter device are defined in the 
private section of the class.

\snippet LowPassFilterPlugin/GLowPassFilter.h variables

The types used to represent parameters are deriving from the GParam class:
- an integers is a GParamInt, 
\snippet LowPassFilterPlugin/GLowPassFilter.h variablesSampleSize
- a double is a GParamDouble, 
\snippet LowPassFilterPlugin/GLowPassFilter.h variablesOutput
- a boolean is a GParamBool,
\snippet LowPassFilterPlugin/GLowPassFilter.h variablesReset
- a bucket that can hold a single parameter is a GSingleParamBucket,
\snippet LowPassFilterPlugin/GLowPassFilter.h variablesInputBucket

A GParamBucket is a placeholder that allwos the user to drag-and-drop, at runtime, any parameter 
defined in any devices present in the LabExe program.



\subsection GLowPassFilterClass-GParamAdvantage Advantages brought by the GParam objects

Here are the advantages provided by those types of objects:
- the device will automatically save the values of those parameters when the program is turned off,
- the values will be restored from the disk at startup,
- those GParam objects provide convenient function in order to display one or several 
graphical interface that automatically synchronize with the actual parameter.
- those gui bring the drag-and-drop-ability that the LabExe provide for parameters to be 
used from/by other devices.



\subsection GLowPassFilterClass-variablesInit Initializing the variables

The parameters are initialized in the constructor of the class and have to be given:
- a short name (that will be displayed by default in the gui),
- a parent (in the sens defined by Qt) which is \e this device object (this is how the device knows what paramters can be saved and restored).

\snippet LowPassFilterPlugin/GLowPassFilter.cpp Initialize the parameters

Some extra initializations and connections to other function can be provided in the body of the contructor.

\snippet LowPassFilterPlugin/GLowPassFilter.cpp Extra initialization the parameters



\subsection GLowPassFilterClass-gui Providing a graphical user interface (gui)

At construction time, a device has no gui of its own. Only when the LabExe program actually needs 
to display the device interface in one or several places of the gui, will it ask the device 
to provide a widget. This is done internally by creating an empty widget and calling the virtual 
function GDevice::PopulateDeviceWidget().

\snippet LowPassFilterPlugin/GLowPassFilter.h PopulateDeviceWidget

When re-implementing this function, the user has to populate the provided widget with 
layouts and other widgets that represent the device interface.

\snippet LowPassFilterPlugin/GLowPassFilter.cpp PopulateDeviceWidgetImplementation



\subsection GLowPassFilterClass-guiBetter More advanced user interface (gui)

Populating the device widget by adding layouts and widgets is easy for devices that have few parameters. 
In the case of a complex user interface, there is another alternative which consists in 
creating the widget by using the Qt-Designer program and have the contructor of this 
new widget class populate itself by accessing the device class. This will be made clearer 
in another tutorial: \ref ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ ZZZZZZZZZZZZZZZZZZZ








*/